#!/usr/bin/env bash
#
# FeedTheChunk
# Licence MIT
#
# Thanks to Dave Eddy over at YSAP.  I've learned a lot from his videos
# If you haven't checked him out, I recommend you give him a view.
#

# Helper functions for scraper

debug(){	# Print DEBUG messages to stout
    # Debug function to print messages when DEBUG 
    # is enabled.
    if [[ $DEBUG -eq 1 ]]; then
        echo -e "[DEBUG]: $1\n"
    fi
}

check_depends() { # check for compatibility
	# check to make sure the user can support all of necessary commands
	# used.
	# Also we'll check if we have the .cache dir available
    local cache=$1
	# Ensure that we have the needed external commands installed.
	if ! command -v html2text >/dev/null 2>&1; then
		return 1 # html2text is not installed
	fi
	# This is probably verbose
	if ! command -v curl >/dev/null 2>&1; then
		return 2 # no curl.  really?
	fi
	# How likely is it that someone is running bash <4 these days?
	if ! type mapfile >/dev/null 2>&1; then
		return 3 # mapfile older version of bash?
	fi
    if [[ ! -d "${cache}" ]]; then
        return 4 # cache directory doesn't exist
    fi

	return 0
}

print_usage() {	# Show usage / help
	# HELP!
	echo "Usage: ${0##*/} [OPTIONS] <team_abbreviation|team_name>"
	echo ""
	echo " This script scrapes the NHL's website's projected lineup "
	echo " for todays games.  You can view the projected lineup for "
	echo " any team playing or view the day's schedule"
	echo ""
	echo "Options:"
	echo "  -s              Print NHL Schedule for today"
	echo "  -h              Display this help message"
	echo ""
	echo "Examples:"
	echo "  ${0##*/} STL           (using 3-letter abbreviation)"
	echo "  ${0##*/} BLUES         (using full team name)"
	echo "  ${0##*/} -s            (print NHL schedule)"
	echo ""
	echo "Available teams:"

	local col=1 # No. of columns to print.
	local count=0
	local -n teams_ref=$1
 
	for key in "${!teams_ref[@]}"; do
		printf " %-20s" "${key}  ${teams_ref[$key]}"
		((count++))
		if [ "$count" -eq $col ]; then
			printf "\\n"
			count=0
		fi
	done | sort -k2 # This only works for col=1
	echo ""

	exit 0
}

get_htmlfile() {    # URL HTMLFILE DEBUG RAW_HTML
    # Download the HTML file from the URL and save it to RAW_HTML. 
    # If DEBUG is 1, copy HTMLFILE to RAW_HTML instead.
    local URL=$1
    local RAW_HTML=$2
    local DEBUG=$3
    local HTMLFILE=$4
    
 	if [[ DEBUG -eq 0 ]]; then
		curl -s "${URL}" >"${RAW_HTML}"
	else

		# For debuggin use a local html file
		$(cp "$HTMLFILE" "${RAW_HTML}") # DEBUG# DEBUG
	fi

}

html_to_text() {	# Convert HTML to raw text
    local RAW_HTML=$1
    local raw_text=$2
	
	# Removes all of the HTML, java, etc from the curl'd web page
	html2text -nobs -width 640 "${RAW_HTML}" >"${raw_text}"

}

get_HTML_date() {	# Grab the published date contained w/in the web page
	# Get the date w/in the HTML file.  Appears that NHL.COM doesn't
	# upload a new file if no games are scheduled, at least during the
	# Olympics break.
	# We'll use this date to determine if the file is valid or not.
	local in_file=false
    local line
    local raw_text=$1
    local published_date=""

	while read -r line; do
		if [[ "${in_file}" == true ]]; then
			published_date="${line}"
			break
		fi
		if [[ "$line" == "@NHLMedia" ]]; then
			in_file=true
		fi

	done <"$raw_text"
    echo "${published_date}"
    return 0
}

check_date() {		# Check if published date > today
	# Check the Published Date contained w/in the HTML with the current date.
	# It seems that if no games are scheduled, NHL doesn't update the page.
	# see 2026 Olympics
    local published_date=$1
	local date_file
	date_file="$(date -d "${published_date}" "+%Y-%m-%d")"
	local date_now
	date_now="$(date +%F)"

	if [[ "$date_file" < "$date_now" ]]; then
		return 1
	fi
	return 0
}

remove_headers() {	# Delete extra from text file that we don't want
	# Remove all of the garage we don't from the Raw Text file
	# Save the cleaned Raw Text to $cleaned
	# NOTE: The file still contains information, Status Report,
	# that we don't want.  We'll remove that after splitting the
	# files into separate game files for simplicity.

    local raw_text=$1
    local cleaned=$2
	# Delete everything from start of file up to and including header
	local header="Fantasy Coverage"

	# Delete everything from footer to the EOF
	local footer="Latest_News"

	# UUOC No more!
	# Stream raw_text from stdin, remove header, remove footer,
	# remove first line and save the output to cleaned
	<"${raw_text}" sed -n '/'"${header}"'/,$p' |
		sed -n '/'"${footer}"'/q;p' |
		tail -n+2 >"${cleaned}"

}

print_schedule() {	# Print today's NHL schedule
	# No need to print schedule for one team.  Just get the lineup,
	# the schedule is printed at the top.
    local cleaned=$1
	local schedule
	local broadcast
	local line
	local team

	# Header
	echo ""
	echo "               Today's NHL Schedule:"
	echo "               ---------------------"

	# Check file date.  Older than 1 day then skip.  No games
	if ! [[ $(find "$cleaned" -mtime +1) ]]; then
		mapfile -t schedule < <(grep "\*\*\*\*\*" "${cleaned}") # shellcheck
		# mapfile -t "$schedule" < <(grep "\*\*\*\*\*" "${cleaned}")
	fi

	while IFS= read -r line; do
		# Sanitize input line: remove CR, control chars, DEL, and NBSP
		line="${line//$'\r'/}"
		line="${line//$'\u00A0'/ }"
		line=$(printf '%s' "$line" | tr -d '\000-\037\177')

		if [[ "$line" =~ ^\*\*\*\*\* ]]; then
			echo ""
			echo "$line"
			continue
		fi
		# Check if this line is a broadcast time line
		broadcast_time "$line"
		broadcast=$?
		if [[ $broadcast -eq 0 ]]; then	# Broadcast line, print it
			echo -e "\t$line"
		fi
	done <"${cleaned}"
	echo ""

}

make_game_files() {	# Make file per game being played
    # Split the cleaned text file into one file per game
    local cleaned=$1
    local gamefile=$2   # This probably should be hardcoded to game-
	# Spit inputfile into 1 file per game / lineup
	# 1) Creates one extra file game-00
	# 2) It's adding 6 line feeds to the end of the files except for the last one
	# 		Must create ever game file bc we need to grep each file to find
	# 		the game we want the lineup for
	local pat="\*\*\*\*\* "

	csplit -s "${cleaned}" -f "${gamefile}" "/${pat}/" "{$(($(grep -c "${pat}" "${cleaned}") - 1))}"

}

remove_status_report() {	# Remove all from Status Report to EOF
	# Removes the status report from the bottom of all of game files

	# ----------------------------------------------------------------
	# TODO -----------------------------------------------------------
	# Probably should only do this for the game we are interested in.
	# ----------------------------------------------------------------
    local cleaned=$1
	local dir="${cleaned%/*}" # Get just the path
	local pat="game-*"        # Pattern to match files
	local file
	local str2find="Status report"

	# Loop through each file matching the pattern
	for file in "${dir}"/${pat}; do
		# Check if it's a regular file
		if [[ -f "$file" ]]; then
			# Remove lines from str2find to end of file
			sed -n -i '/'"${str2find}"'/q;p' "$file"
		fi
	done
}

resolve_team_name() {	# Get team name for 3 letter abriviation
	# Resolves a team name from either 3-letter abbreviation or full name
	# If abbreviation (key) is provided, returns the long team name
	# If full name is provided, returns it as-is
	# Returns 0 if neither abbreviation nor team name is found
	local input="$1"
	local input_upper="${input^^}" # Convert to uppercase

	# Check if input is a key (3-letter abbreviation) in the teams_long array
	if [[ -v teams_long["${input_upper}"] ]]; then
		echo "${teams_long["${input_upper}"]}"
		return 0
	fi

	# Check if input matches any full team name in the array
	for team_name in "${teams_long[@]}"; do
		if [[ "${team_name}" == "${input_upper}" ]]; then
			echo "${input_upper}"
			return 0
		fi
	done

	# Team not found (misspelled abbreviation or full name)
	# echo 0
	return 1
}

find_gamefile() {	# Find the game file for the supplied team
	# This is a helper function to find the team we're interested in
	# It will print the line number and the line itself
	local team="$1"
	local gamefile="$2"

	# Returns the name of file that contains the team name
	# There should only ever be one file returned
	grep -l "${team}" "${gamefile}"*
	
}

print_game_info() {	# Print the Lineup for the requested team
	# Parse and print the game file with formatted output
	# Initialize variables
	local game_file="$1"
	local team="$2"
	local current_section=""
	local in_injured_section=false
	local in_scratched_section=false
	local in_game=false
	local player_count
	local broadcast # 0=broadcast line 1=not a broadcast line

	# Convert team to uppercase for case-insensitive comparison
	team="${team^^}"

	if [[ ! -f "${game_file}" ]]; then
		echo "Game file not found: ${game_file}"
		return 1
	fi

	echo

	# Read the file and format it
	while IFS= read -r line; do
		# Sanitize input line: remove CR, control chars, DEL, and NBSP
		line="${line//$'\r'/}"
		line="${line//$'\u00A0'/ }"
		line=$(printf '%s' "$line" | tr -d '\000-\037\177')

		# Game header
		if [[ "$line" =~ ^\*\*\*\*\* ]]; then
			echo ""
			echo "$line"
			continue
		fi

		broadcast_time "$line"
		broadcast=$?
		if [[ "$broadcast" -eq 0 ]]; then
			echo "$line"
			echo ""
			continue
		fi

		# Team lineup header
		if [[ "$line" =~ "projected lineup" ]]; then
			# If this is the team the user wants,
			# set in_game flag to true and print the header,
			# otherwise set it to false to skip until next game header
			if [[ "${line^^}" =~ ^"${team^^}" ]]; then
				in_game=true
				echo ""
				echo "$line"
				# Underline the header with '-' repeated to match its length
				local header_len=${#line}
				local underline
				underline=$(printf '%*s' "$header_len" '' | tr ' ' '-')
				echo "$underline"

				current_section=""
				in_scratched_section=false
				in_injured_section=false
				continue
			else
				in_game=false
				continue

			fi
		fi

		# Scratched section
		if [[ "$line" =~ ^Scratched ]] && [[ "$in_game" == true ]]; then
			echo ""
			echo "Scratched:"
			current_section=""
			# If the line contains player names after a colon, print them
			local rest="${line#Scratched:}"
			rest="${rest# }"
			if [[ -n "${rest// /}" ]]; then
				# split by ", " and print each on its own line
				echo "${rest//, /$'\n'}"
				in_scratched_section=false
			else
				in_scratched_section=true
			fi
			continue
		fi

		# Injured section
		if [[ "$line" =~ ^Injured ]] && [[ "$in_game" == true ]]; then
			echo ""
			echo "Injured:"
			current_section=""
			# If the line contains player names after a colon, print them (stripping parentheticals)
			local rest="${line#Injured:}"
			rest="${rest# }"
			if [[ -n "${rest// /}" ]]; then
				rest="${rest// ([^)]*)/}"
				# rest=$(echo "$rest" | sed 's/ ([^)]*)//g')
				echo "${rest//, /$'\n'}"
				in_injured_section=false
			else
				in_injured_section=true
			fi
			continue
		fi

		# Regular lines
		# If we're currently in Injured or Scratched multi-line section, print players
		if [[ "${in_injured_section}" == true || "${in_scratched_section}" == true ]]; then
			if [[ -z "$line" ]]; then
				in_injured_section=false
				in_scratched_section=false
				# preserve blank line
				echo ""
				continue
			fi
			# If this line is a new header, clear flags and let it be processed normally
			if [[ "$line" =~ "projected lineup" ]] || [[ "$line" =~ ^\*\*\*\*\* ]] || [[ "$line" =~ ^[0-9].*\.(m|M)\. ]] || [[ "$line" =~ ^Scratched ]] || [[ "$line" =~ ^Injured ]]; then
				in_injured_section=false
				in_scratched_section=false
				# fall through to normal processing
			else
				local player_line="$line"
				if [[ "${in_injured_section}" == true ]]; then
					player_line="${player_line// ([^)]*)/}"
				fi
				player_line="${player_line//, /$'\n'}"
				echo "$player_line"
				continue
			fi

		fi
		if [[ -n "$line" ]] && [[ "$in_game" == true ]]; then
			local formatted_line="$line"
			# Replace " --- " with a newline
			formatted_line="${formatted_line// -- /$'\n'}"

			# Count the number of players (lines after splitting)
			player_count=$(echo "$formatted_line" | grep -c .)

			# If formated_line contains 3 players: Forwards section
			if [[ $player_count -eq 3 ]]; then
				if [[ "${current_section}" != "forwards" ]]; then
					echo ""
					echo "Forwards"
					current_section="forwards"
				fi
			fi

			# If formated_line contains 2 players: Defensemen section
			if [[ $player_count -eq 2 ]]; then
				if [[ "${current_section}" != "defensemen" ]]; then
					echo ""
					echo "Defensemen"
					current_section="defensemen"
				fi
			fi

			# If formated_line contains 1 player: Goaltenders section
			if [[ $player_count -eq 1 ]] && [[ "${current_section}" != "goaltenders" ]]; then
				echo ""
				echo "Goalies"
				current_section="goaltenders"

			fi

			# Check if we're leaving injured or scratched section (empty line or new section header)
			if [[ -z "$formatted_line" ]] || [[ "$formatted_line" =~ ^[A-Z].* ]]; then
				in_injured_section=false
				in_scratched_section=false
			fi

			echo "$formatted_line"
		elif [[ "$in_game" == true ]]; then
			# Preserve blank lines
			echo ""
		fi
	done <"$game_file"

	echo
}

broadcast_time() {	# Get the broadcast time from the game file
	# Retrieve the game time from:
	# Raw Text file :: Used with Schedule
	# game-xx file  :: Used with lineup
	local line=$1

	if [[ "$line" =~ ^[0-9].*\.(m|M)\. ]]; then #line == broadcast time
		return 0
	else
		return 1
	fi

}

clean_cache() {		# Cleanup the cache
	local cleaned=$1
	local GAMEFILE=$2
	local raw_text=$3
	local RAW_HTML=$4
	
	# Remove all cached files
	if [[ $DEBUG -eq 0 ]]; then
		rm -f "${cleaned}"
		rm -f "${GAMEFILE}"* # Delete the individual game files
		rm -f "${raw_text}"  # Delete the raw text file
		rm -f "${RAW_HTML}"  # Delete the raw html file
	fi
}
